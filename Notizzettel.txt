// =====================================================================
// Notizzettel.txt
// =====================================================================

Modern C++ / Firmenseminar RMB Bremen

peter.loos@gmx.de

Peter Loos // "Du"

C++/C ,  Java, C#, Android, (( Python ))

JavaScript

2 Tools:

a) Visual Studio

b) GitHub


Inhalt:

Kenntnisse  / Erwartungen

MT (std::async)  // Feature , Promises
Move-Semantik
Templates 
Type Traits
constexpr
constexpr if


// =====================================================================

Pause 10.30  // 15

Bis 17 Uhr

Mittagspause : Egal

// =====================================================================


Move-Semantics:

==>: ... 420   // Ursprungs-Objekt: Wird freigegeben
==>: ... 110

// =====================================================================

==>: ... 7000  // Ursprungs-Objekt: Wird freigegeben

// =====================================================================

==>: ... B40   // 


// =====================================================================


C++:

== OO: Objekt-Orientiert

== GP: Generische Programmierung  


Zum 3-Ebenenmodell der Template-Instanzierung:

https://github.com/pelocpp/cpp_modern_examples/blob/master/GeneralSnippets/TemplateClassBasics/TemplatesClassBasics.md

// =====================================================================


Lambda-Funktionen


// =====================================================================

Cpp Insights:

https://cppinsights.io/

// =====================================================================

class X
{
  public:
     void print () {}
};

void test () 
{
   X x();
   // X x = new X();  // C# / Java

   x.print();
}

// =====================================================================

"Zu jedem new gehört ein delete"  :)

Death March


Idee:

RAII

== Pointer   / 'raw' Zeiger

== Hüllenklasse / Hüllenobjekt:

   Dieses Objekt kapselt den Zeiger

   Veranwortlich für den delete Aufruf !

== OO: Konstruktoren, Destruktoren

== Destruktoren ===> wird deterministisch aufgerufen.

== Hüllenobjekte:  lokales Objekt

== Konstruktor:  new / Zeiger wird übergeben

== Destruktor:   Kann den Zeiger freigeben (delete) ...
                 oder seinen Gebrauch "mitzählen"

Fazit: Der Anwender ruft delete  NICHT mehr auf.


a) auto_ptr

b) std::unique_ptr
   std::shared_ptr

   Strategie:  

i) std::unique_ptr:

   Zu EINEM Zeitpunkt kann ein std::unique_ptr
   nur EINEN Besitzer haben.


ii) std::shared_ptr:

    Zu EINEM Zeitpunkt kann ein std::shared_ptr
    MEHRERE Besitzer haben.

    Kommen in die Nähe von C#/Java: Garbage Collection

    Stichwort: Referenz Zähler

iii) Wehrmutstropfen: Der std::shared_ptr
     funktioniert nicht immer :-(((

      std::weak_ptr

